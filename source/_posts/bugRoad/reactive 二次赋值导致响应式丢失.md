---
title: reactive 二次赋值导致响应式丢失
categories:
  - [BugRoad]
tags: 
  - BugRoad
---

# reactive 二次赋值导致响应式丢失

## 场景一

```js
let h = reactive({ m: 1 })
h = { m: 2 } // 响应式丢失
```

`javascript` 中所有数据类型都是通过 `值传递` 的。

当然引用数据类型也不例外，那既然是按值传递，为什么会出现响应式丢失的问题呢?

原因很简单，h 的值实际上是 `{ m: 1 }` 的地址。然后再次赋值，会导致 h 的值，也就是地址发生变化，从而指向普通的对象上，自然失去了响应式。

## 场景二

```js
let h = reactive({ a: 1, m: { n: 1 } })
const h2 = reactive({ ...h })
h2.a = 2
h2.m.n = 2
console.log(h.a, h2.a) // 1 2
console.log(h.m.n, h2.m.n) // 2 2
```

> 通常存在的误区：通过解构对象得到的数据，可以作为深拷贝的一种形式？！

对于基本数据类型确实是可以的，但是对于引用数据类型则不然。值仍然是以地址的形式存在。因此在修改的时候，实际上还是会也影响到源数据。

## 总结

前端这块儿，对于引用数据类型要万分小心。特别是类似对于表单操作时，表单中存在引用数据类型的属性，在重置的时候不能单单的只将最外层重置。

或者使用 `lodash` 中封装的深拷贝，在使用的时候就进行深度拷贝，以不影响源数据。
