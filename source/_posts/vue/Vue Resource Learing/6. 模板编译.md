---
title: 源码学习 - 模板编译
categories:
  - [Vue,源码]
tags: 
---

# 模板编译

## 大体步骤

主要的步骤是：先将模板编译成 `AST`，然后再将其转换成 渲染函数，也就是熟悉的 `render`函数。

但是有一些不存在变量的节点，是不需要重新渲染的，所以 `Vue` 对其做了相应的优化，也就是将所有的静态节点进行标记，最终在生成 `render` 函数

所以大体逻辑，可以分成三个部分：

- 将模板编译成 AST
- 遍历 AST 标记静态节点
- 使用 AST 生成渲染函数

这三部分在源码中是分成三个模块去执行：

- 解析器
- 优化器
- 代码生成器

![image-20230308103949419](https://s2.loli.net/2023/03/08/b5RofgcjlB6G1hI.png)

## 解析器

### 解析器作用

`template -> AST`

这一模块主要就是将 模板 编译成 AST。

例如： 

```vue
<template>
  <div>
    <p>{{ name }}</p>
  </div>
</template>
```

上面简单的模板编译成 AST 之后是这样的。

```json
{
  "type": 1,
  "tag": "div",
  "attrsList": [],
  "attrsMap": {},
  "rawAttrsMap": {},
  "children": [
    {
      "type": 1,
      "tag": "p",
      "attrsList": [],
      "attrsMap": {},
      "rawAttrsMap": {},
      "parent": "[Circular ~]",
      "children": [
        {
          "type": 2,
          "expression": "_s(name)",
          "tokens": [
            {
              "@binding": "name"
            }
          ],
          "text": "{{ name }}",
          "start": 10,
          "end": 20,
          "static": false
        }
      ],
      "start": 7,
      "end": 24,
      "plain": true,
      "static": false,
      "staticRoot": false
    }
  ],
  "start": 0,
  "end": 31,
  "plain": true,
  "static": false,
  "staticRoot": false
}
```

所谓的 `AST` 实际上就是通过 `Object` 的形式描述模板的各个状态以及属性。

### 解析器内部原理

`正则` 

实际上，解析器内部拆分了好多个子解析器，例如：HTML解析器、文本解析器、过滤解析器...其中最重要的就是 HTML解析器，在解析的过程中，会不断的触发一系列的钩子函数：

- 文本钩子
- 注释钩子
- 开始标签钩子
- 结束标签钩子

解析器的工作过程，就是拿到模板之后进行循环遍历，通过正则进行匹配，一段一段的裁剪，以及采用栈的形式，确保 AST 的层级关系，直到模板被截取空。

其中需要注意的是，自闭合标签的处理。自闭合标签实际上就是在开始标签的末尾存在 `/` 。

```js
/** 属性 */
const attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/
/** 标签名 */
/** <my-card></my-card> */
const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z${unicodeRegExp.source}]*`
/** <component:child></component:child> */
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
/** < */
const startTagOpen = new RegExp(`^<${qnameCapture}`)
/** > || /> */
const startTagClose = /^\s*(\/?)>/
/** </div> */
const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`)
```

### 大体过程

`实际上 开始标签 和 结束标签 之前还有 注释、条件注释、DOCTYPE`

![image-20230308144858685](https://s2.loli.net/2023/03/08/VMaqS3xOLyjDtEZ.png)

## 优化器

所谓优化，即遍历 AST 将所有的静态节点找到，并且进行标记。

作用：

- 每次重新渲染时，不需要为静态子树创建新节点
- 在 `patch` 过程中可以跳过

主要标记有俩：`static`  `staticRoot`

```js
/** packages\vue-template-compiler\browser.js */
function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}
```

## 代码生成器

`AST -> render`

所谓的 `render` 函数，实际上就是函数的嵌套，这个嵌套函数是通过遍历 `AST`，拼接而成的 。

```js
/**
<div id="el">Hello {{name}}</div> -> AST -> render
render: 
with(this) {
return _c("div", {attrs: { "id": "el" }}, [_v("hello" + _s(name))])
}
*/
```

涉及到的函数有：`_c` `_v` `_s`

`_c`：其实就是 `createElement(tagName, attrs, children)`

最为主要的函数就是 `genElement`

```js
function genElement(el, state) {
  const data = el.plain ? undefined : genData(el, state)
  const children = genChildren(el, state)
  code = `_c('${el.tag}'${data ? `,${data}`: ''}${children ? `,${children}`: ''})`
  return code
}
```

