---
title: 前端埋点
categories: 
  - JavaScript
tags:
  - JavaScript
---

# 前端埋点

## 什么是埋点？

前端埋点是一种在 Web 应用程序中用于监控和记录用户行为的技术，通常通过客户端脚本来实现。

前端埋点可以对用户访问网站的路径、浏览器信息、操作行为、错误日志等进行跟踪和分析。通过收集这些数据，开发人员可以更好地了解用户使用应用程序的方式，并做出相应的决策来优化用户体验和提高应用程序的性能。

## 埋点方式

目前常见的埋点上报方式有：ajax、img、navigator.sendBeacon。

### 基于ajax的埋点上报

埋点实际上是对关键节点的数据进行上报和服务端交互的一个过程，因此与后端约定的接口是必要的。

实现方式：

```js
function buryingPointAjax (url, data) {
  return new Promise((resole, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("post", url, true);
    xhr.send(data);
  })
}
```

缺点：一般而言，埋点域名不是当前域名，因此请求存在跨域问题。

### 基于img的埋点上报

介于 ajax 可能存在跨域问题，我们采用一些支持跨域的标签无疑是更好的选择，比如：script、link、img。

但 script 以及 link 是需要创建 dom 节点，并挂载到页面上的，反复操作 dom 必然会导致页面的卡顿，并且载入 js/css 资源还会阻塞页面的渲染，因此这俩并不合适。

img 标签本身不会阻塞页面的解析和渲染，因为浏览器此时采用的是渐进式渲染，在遇到 img 标签时，会立即下载图片资源，并不会等待图片加载完成后在继续解析和渲染下面的内容，而是预留相应的空间保证后续的渲染。

实现方式：

```js
const buryingPointImg = new Image();
buryingPointImg.src = "http://example.com/xxx.png";
```

优点：

1. img 兼容性好
2. 无需挂载到 dom，反复操作 dom
3. img 的加载不会阻塞页面的解析与渲染

缺点：不适合处理大量数据和复杂的同级需求

> 通常埋点上报会使用 GIF 图，合法的 GIF 只需要 43 个字节。

### 基于Navigator.sendBeanCon的埋点上报

`Navigator.sendBeanCon(url: string, params: any)：boolean`

该方法是通过 HTTP POST 将少量数据，异步传输到服务器，避免了传统技术（XML）发送数据的一些问题。

`navigator.sendBeacon()` 方法将数据发送到服务器时，这个方法会在后台异步地创建一个 HTTP 请求，并将数据发送给指定的 URL，并返回一个 boolean 值：true 表示成功加入执行队列，false 表示因浏览器执行队列栈已满，未加入其中，因此发的返回值并不能判断请求是否成功，但浏览器会尽力保证。

优点：

1. 相对于 img，更加规范，数据上传可以传输资源类型更多。
2. 异步传输，不回影响页面之间跳转，且不受同域限制。

## 常见埋点

### 点击触发埋点

绑定点击事件，当点击目标元素时，触发埋点上报。

```js
function clickButton(url, data) {
    navigator.sendBeacon(url, data)
}
```

### 页面停留时间上报埋点

路由文件中，初始化一个startTime，当页面离开时通过路由守卫计算停留时间。

```js
let url = ''// 上报地址
let startTime = Date.now()
let currentTime = ''
router.beforeEach((to, from, next) => { 
     if (to) {
         currentTime = Date.now()
         stayTime = parseInt(currentTime - startTime)
         navigator.sendBeacon(url, {time: stayTime})
         startTime = Date.now()
     }
 })
```

### 错误监听埋点

通过监听函数去接收错误信息。

#### vue错误捕获

```js
app.config.errorHandler = (err) => { 
    navigator.sendBeacon(url, {error: error.message, text: 'vue运行异常' })
}
```

#### JS异常与静态资源加载异常

```js
window.addEventListener('error', (error) => { 
    if (error.message) { 
        navigator.sendBeacon(url, {error: error.message, text: 'js执行异常' })
    } else { 
        navigator.sendBeacon(url, {error: error.filename, text: '资源加载异常' })
    } 
}, true)
```

#### 请求错误捕获

```js
axios.interceptors.response.use(
  (response) => {
    if (response.code == 200) {
      return Promise.resolve(response);
    } else {
      return Promise.reject(response);
    }
  },
  (error) => {
    // 返回错误逻辑
    navigator.sendBeacon(url, {error: error, text: '请求错误异常' })
  }
);
```

### 内容可见埋点

通过交叉观察器去监听当前元素是否出现在页面

```js
// 可见性发生变化后的回调 
function callback(data) { 
    navigator.sendBeacon(url, { target: data[0].target, text: '内容可见' }) 
} 
// 交叉观察器配置项 
let options = {}; 
// 生成交叉观察器 
const observer = new IntersectionObserver(callback); 
// 获取目标节点 
let target = document.getElementById("target"); 
// 监听目标元素 
observer.observe(target);
```

## 参考资料

[三分钟，教你3种前端埋点方式！](https://mp.weixin.qq.com/s/yV35Fy1lGWbeH5AS97Hzjg)