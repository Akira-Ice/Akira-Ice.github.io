---
title: 闭包
date: 2021/10/15
updated: 2021/10/15
categories:
  - [JavaScript, 核心]
tags:
---

# 闭包

> **闭包是一种特殊对象**
>
> **它由两部分组成。执行上下文 A，以及 A 中所创建的函数 B**
>
> **当 B 在执行时，访问了 A 中变量对象的值，闭包由此产生**

```javascript
// demo01
function foo() {
  var a = 20;
  var b = 30;

  function bar() {
    return a + b;
  }

  return bar;
}

var bar = foo();
bar();
```

上面的例子，首先有执行上下文 foo，在 foo 中定义了函数 bar，而通过对外返回 bar 的方式让 bar 得以执行。当 bar 执行时，访问了 foo 内部的变量 a，b。因此这个时候闭包产生。

闭包的产生，导致引用始终存在，会阻止 JavaScript 垃圾回收，延长变量的生命周期

```javascript
var fn = null;
function foo() {
  var a = 2;
  function innnerFoo() {
    console.log(a);
  }
  fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn
}

function bar() {
  fn(); // 此处的保留的innerFoo的引用
}

foo();
bar(); // 2
```

闭包 foo 的作用域链：

![](https://s2.loli.net/2023/03/05/di1xyfKZC9YDS3M.webp)

**通过闭包，我们可以在其他的执行上下文中，访问到函数内部的变量，但是闭包的作用域并不会发生变化**

```javascript
var fn = null;
function foo() {
  var a = 2;
  function innnerFoo() {
    console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误
    console.log(a);
  }
  fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn
}

function bar() {
  var c = 100;
  fn(); // 此处的保留的innerFoo的引用
}

foo();
bar();
```

### 闭包的应用场景

- **柯里化**

- **模块化**

  ```
  (function () {
    var a = 10;
    var b = 20;

    function add(num1, num2) {
      var num1 = !!num1 ? num1 : a;
      var num2 = !!num2 ? num2 : b;

      return num1 + num2;
    }

    window.add = add;
  })();

  add(10, 20);
  ```

  ![](https://s2.loli.net/2023/03/05/pyT9x17QY3JRcEI.webp)
